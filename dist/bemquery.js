/*! bemquery v0.1.5 | (c) 2016-2017 BEMQuery team | MIT license (see LICENSE) */class Selector{constructor(h,i){this.BEM=h,this.CSS=i,Object.freeze(this)}}function endsWithModifier(h,i){const j=new RegExp(`[^${i.elemSeparator}${i.modifierSeparator}]+${i.modifierSeparator}[^${i.elemSeparator}${i.modifierSeparator}]+$`,'g');return!!h.match(j)}function getSelectorWithoutModifier(h,i){return` ${h.substring(h.lastIndexOf('.'),h.lastIndexOf(i))}`}const defaultConfig={bem:{elemSeparator:'__',modifierSeparator:'_'},rules:{default(h){return`.${h}`},' > '(h,i){return` ${i.rules.default(h)}`},' '(h,i,j){return endsWithModifier(j,i.bem)?`${getSelectorWithoutModifier(j,i.bem.modifierSeparator)}${i.bem.elemSeparator}${h}`:`${i.bem.elemSeparator}${h}`},':'(h,i){return`${i.bem.modifierSeparator}${h}`}}};function convertToken(h,i,j=''){const k=i.rules,l=h.shift();let m,n;if(!l)return j;if(j?(n=h.shift(),m=k[l]):(n=l,m=k.default),'function'!=typeof m)throw new SyntaxError('Malformed BEM rule');return j+=m(n,i,j),convertToken(h,i,j)}function convert(h,i){const j=Object.keys(i.rules).filter(m=>{return'default'!==m}),k=new RegExp(`(${j.join('|')})`,'g'),l=h.split(k);return h=convertToken(l,i),h}class Converter{constructor(h=defaultConfig){this.config=h}convert(h){const i=convert(h,this.config);return new Selector(h,i)}getStateFromClass(h){if('string'!=typeof h)throw new TypeError('Class must be a string.');const i=this.config.bem,j=new RegExp(`[^${i.elemSeparator}${i.modifierSeparator}]+${i.modifierSeparator}([^${i.elemSeparator}${i.modifierSeparator}]+)$`),k=h.match(j);return k?k[1]:null}}function factory$2(h=defaultConfig){const i=new Converter(h);return i}class SelectorEngine{find(h,i=document){let j=!1;i!==document&&(!i.id&&(j=!0,i.id=`BEMQueryTMP_${Date.now()}`),h=`#${i.id} ${h}`);const k=Array.from(i.querySelectorAll(h));return j&&i.removeAttribute('id'),k}}function checkConverter(h){return'object'==typeof h&&'function'==typeof h.convert}function checkSelectorEngine(h){return'object'==typeof h&&'function'==typeof h.find}function determineContext(h){return h instanceof BEMQuery&&(h=h.elements[0]),h instanceof HTMLElement||h===document||(h=document),h}function fetchElements(h,i,j,k){if(!h)throw new TypeError('Selector must be set.');if('string'==typeof h)return h=j.convert(h).CSS,k.find(h,i);if(h instanceof HTMLElement)return[h];if(h instanceof BEMQuery)return h.elements;if('object'==typeof h)return Array.from(h);throw new TypeError('Selector must be a string, object, array or DOM element.')}function defineProperties(h,i){Object.defineProperty(h,'elements',{value:i}),h.elements.forEach((j,k)=>{Object.defineProperty(h,k,{enumerable:!0,get(){return new BEMQuery(this.elements[k],document,this.converter,this.selectorEngine)}})},h),Object.defineProperty(h,'length',{enumerable:!0,get(){return this.elements.length}})}class BEMQuery{constructor(h,i,j,k){if(!checkConverter(j))throw new TypeError('Converter must be an object with convert method defined.');if(!checkSelectorEngine(k))throw new TypeError('SelectorEngine must be an object with find method defined.');this.converter=j,this.selectorEngine=k,i=determineContext(i),defineProperties(this,fetchElements(h,i,j,k))}get(h){if(h=+h,Number.isNaN(h))throw new TypeError('Index must be a correct Number.');else if(0>h)throw new RangeError('Index must be greater or equal to 0.');else if(h>this.elements.length-1)throw new RangeError('Index cannot be greater than collection\'s length.');return new BEMQuery(this.elements[h],document,this.converter,this.selectorEngine)}each(h){if('function'!=typeof h)throw new TypeError('Callback must be a function.');const i=this.converter,j=this.selectorEngine;return this.elements.forEach(k=>{h(new BEMQuery(k,document,i,j))}),this}[Symbol.iterator](){let h=0;const i=this.elements,j=this.converter,k=this.selectorEngine;return{next(){if(h<i.length){const l=i[h++];return{value:new BEMQuery([l],document,j,k),done:!1}}return{done:!0}}}}}function factory(h,i=document){const j=factory$2(),k=new SelectorEngine,l=new BEMQuery(h,i,j,k);return l}var $$1=Object.freeze({BEMQuery:BEMQuery,default:factory});class Batch{constructor(){this.read=[],this.write=[]}add(h,i){if('read'!==h&&'write'!==h)throw new TypeError('Type must be either \'read\' or \'write\'.');if('function'!=typeof i)throw new TypeError('Task must be a function.');this[h].push(i)}run(h='read'){if('read'!==h&&'write'!==h)throw new TypeError('Type must be either \'read\' or \'write\'.');return new Promise(i=>{requestAnimationFrame(()=>{const j=[];return this[h].forEach(k=>{j.push(k())}),this[h]=[],i(j)})})}}BEMQuery.prototype.read=function(){return this.batch||(this.batch=new Batch),this.batch.run('read')},BEMQuery.prototype.write=function(){return this.batch||(this.batch=new Batch),this.batch.run('write')},BEMQuery.prototype.html=function(h){return this.batch||(this.batch=new Batch),'undefined'==typeof h?this.batch.add('read',()=>{const i=this.elements,j=[];return i.forEach(k=>{j.push(k.innerHTML)}),j}):(h+='',this.batch.add('write',()=>{const i=this.elements;i.forEach(j=>{j.innerHTML=h})})),this};function processClasses(h,i){const j=[];return[].forEach.call(i.classList,k=>{const l=h.getStateFromClass(k+'');l&&j.push(l)}),j}BEMQuery.prototype.getStates=function(){this.batch||(this.batch=new Batch);const h=this.elements;return this.batch.add('read',()=>{const i=[];return h.forEach(j=>{i.push(processClasses(this.converter,j))}),i}),this};class ListenersStorage{constructor(){this.storage=new WeakMap}add(h,i,j,k,l){let m={};this.storage.has(h)&&(m=this.storage.get(h)),'undefined'==typeof m[i]&&(m[i]={}),'undefined'==typeof m[i][j]&&(m[i][j]=[]),m[i][j].push([k,l]),this.storage.set(h,m)}get(h,i,j,k){if(!this.storage.has(h))return null;const l=this.storage.get(h);if('undefined'==typeof l[i]||'undefined'==typeof l[i][j])return null;for(let m of l[i][j])if(m[0]===k)return m[1];return null}remove(h,i,j,k){if(!this.storage.has(h))return null;const l=this.storage.get(h);return'undefined'==typeof l[i]||'undefined'==typeof l[i][j]?null:(l[i][j].forEach((m,n)=>{m[0]===k&&l[i][j].splice(n,1)}),null)}}const storage=new ListenersStorage;BEMQuery.prototype.on=function(h,i,j){let k;if('string'!=typeof h||!h)throw new TypeError('Type of event must be a non-empty string.');if('string'!=typeof i&&'function'!=typeof i||!i)throw new TypeError('Selector must be a non-empty string or function.');if('string'==typeof i){if('function'!=typeof j)throw new TypeError('Callback must be a function.');i=this.converter.convert(i).CSS,i=`${i}, ${i} *`,k=l=>{l.target.matches(i)&&j(l)}}else k=i;return this.elements.forEach(l=>{l.addEventListener(h,k,!1),'string'==typeof i&&storage.add(l,h,i,j,k)}),this},BEMQuery.prototype.off=function(h,i,j){let k;if('string'!=typeof h||!h)throw new TypeError('Type of event must be a non-empty string.');if('string'!=typeof i&&'function'!=typeof i||!i)throw new TypeError('Selector must be a non-empty string or function.');if('string'==typeof i){if('function'!=typeof j)throw new TypeError('Callback must be a function.');i=this.converter.convert(i).CSS,i=`${i}, ${i} *`}else k=i;return this.elements.forEach(l=>{'string'==typeof i&&(k=storage.get(l,h,i,j),storage.remove(l,h,i,j)),l.removeEventListener(h,k,!1)}),this};export default $$1;
//# sourceMappingURL=bemquery.js.map
