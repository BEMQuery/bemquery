{"version":3,"file":null,"sources":["../node_modules/bemquery-selector-converter/dist/bemquery-selector-converter.js","../node_modules/bemquery-core/dist/bemquery-core.js","../node_modules/bemquery-async-dom/dist/bemquery-async-dom.js","../node_modules/bemquery-selector-engine/dist/bemquery-selector-engine.js","../node_modules/bemquery-dom-events/dist/bemquery-dom-events.js"],"sourcesContent":["/*! bemquery-selector-converter v0.1.4 | (c) 2016 BEMQuery team | MIT license (see LICENSE) */\n/** Simple class representing selector */\nclass Selector {\n\t/**\n\t * Creates new Selector instance.\n\t *\n\t * @param {String} BEM BEM version of selector.\n\t * @param {String} CSS CSS version of selector.\n\t */\n\tconstructor( BEM, CSS ) {\n\t\t/**\n\t\t * BEM version of selector.\n\t\t *\n\t\t * @property {String}\n\t\t */\n\t\tthis.BEM = BEM;\n\n\t\t/**\n\t\t * CSS version of selector.\n\t\t *\n\t\t * @property {String}\n\t\t */\n\t\tthis.CSS = CSS;\n\n\t\tObject.freeze( this );\n\t}\n}\n\nfunction endsWithModifier( selector, bemConfig ) {\n\tconst regex = new RegExp( `[^${bemConfig.elemSeparator}${bemConfig.modifierSeparator}]+${bemConfig.modifierSeparator}[^${bemConfig.elemSeparator}${bemConfig.modifierSeparator}]+$`,\n\t\t'g' );\n\n\treturn !!selector.match( regex );\n}\n\nfunction getSelectorWithoutModifier( selector, modifierSeparator ) {\n\treturn ` ${selector.substring( selector.lastIndexOf( '.' ), selector.lastIndexOf( modifierSeparator ) )}`;\n}\n\nconst defaultConfig = {\n\tbem: {\n\t\telemSeparator: '__',\n\t\tmodifierSeparator: '_'\n\t},\n\trules: {\n\t\tdefault( token ) {\n\t\t\treturn `.${token}`;\n\t\t},\n\n\t\t' > '( token, config ) {\n\t\t\treturn ` ${config.rules.default( token )}`;\n\t\t},\n\n\t\t' '( token, config, selector ) {\n\t\t\tif ( endsWithModifier( selector, config.bem ) ) {\n\t\t\t\treturn `${getSelectorWithoutModifier( selector, config.bem.modifierSeparator )}${config.bem.elemSeparator}${token}`;\n\t\t\t}\n\n\t\t\treturn `${config.bem.elemSeparator}${token}`;\n\t\t},\n\n\t\t':'( token, config ) {\n\t\t\treturn `${config.bem.modifierSeparator}${token}`;\n\t\t}\n\t}\n};\n\nfunction convertToken( tokens, config, selector = '' ) {\n\tconst rules = config.rules;\n\tconst delimeter = tokens.shift();\n\tlet rule;\n\tlet token;\n\n\tif ( !delimeter ) {\n\t\treturn selector;\n\t} else if ( !selector ) {\n\t\ttoken = delimeter;\n\t\trule = rules.default;\n\t} else {\n\t\ttoken = tokens.shift();\n\t\trule = rules[ delimeter ];\n\t}\n\n\tif ( typeof rule !== 'function' ) {\n\t\tthrow new SyntaxError( 'Malformed BEM rule' );\n\t}\n\n\tselector += rule( token, config, selector );\n\n\treturn convertToken( tokens, config, selector );\n}\n\nfunction convert( selector, config ) {\n\tconst rules = Object.keys( config.rules ).filter( ( rule ) => {\n\t\treturn rule !== 'default';\n\t} );\n\tconst splitRule = new RegExp( `(${rules.join( '|' )})`, 'g' );\n\tconst splittedSelector = selector.split( splitRule );\n\n\tselector = convertToken( splittedSelector, config );\n\n\treturn selector;\n}\n\n/** Converter's class*/\nclass Converter {\n\t/**\n\t * Create converter's instance.\n\t *\n\t * @param {Object} [config=defaultConfig] converter's configuration options.\n\t * @class\n\t */\n\tconstructor( config = defaultConfig ) {\n\t\t/**\n\t\t * Converter's configuration\n\t\t *\n\t\t * @property {Object}\n\t\t */\n\t\tthis.config = config;\n\t}\n\n\t/**\n\t * Converts given selector to CSS.\n\t *\n\t * @param {String} selector BEM selector to be converted.\n\t * @return {Selector} Converted selector.\n\t */\n\tconvert( selector ) {\n\t\tconst convertedSelector = convert( selector, this.config );\n\n\t\treturn new Selector( selector, convertedSelector );\n\t}\n\n\t/**\n\t * Get state from given `[class]` attribute contents.\n\t *\n\t * @param {String} className HTML `[class]` attribute.\n\t * @return {String|null} Fetched state.\n\t */\n\tgetStateFromClass( className ) {\n\t\tif ( typeof className !== 'string' ) {\n\t\t\tthrow new TypeError( 'Class must be a string.' );\n\t\t}\n\n\t\tconst bemConfig = this.config.bem;\n\t\tconst regex = new RegExp( `[^${bemConfig.elemSeparator}${bemConfig.modifierSeparator}]+${bemConfig.modifierSeparator}([^${bemConfig.elemSeparator}${bemConfig.modifierSeparator}]+)$` );\n\t\tconst match = className.match( regex );\n\n\t\treturn match ? match[ 1 ] : null;\n\t}\n}\n\n/**\n * BEM selector converter factory.\n *\n * @param {Object} [converterConfig=defaultConverterConfig] Configuration object that\n * should be passed to the Converter constructor.\n * @return {Converter} Converter's instance.\n */\nfunction factory( converterConfig = defaultConfig ) {\n\tconst converter = new Converter( converterConfig );\n\n\treturn converter;\n}\n\nexport { Converter, Selector };export default factory;\n//# sourceMappingURL=bemquery-selector-converter.js.map\n","/*! bemquery-core v0.1.4 | (c) 2016 BEMQuery team | MIT license (see LICENSE) */\nimport bsc from 'bemquery-selector-converter';\nimport SelectorEngine from 'bemquery-selector-engine';\n\nfunction checkConverter( converter ) {\n\treturn typeof converter === 'object' && typeof converter.convert === 'function';\n}\n\nfunction checkSelectorEngine( selectorEngine ) {\n\treturn typeof selectorEngine === 'object' && typeof selectorEngine.find === 'function';\n}\n\nfunction determineContext( context ) {\n\tif ( context instanceof BEMQuery ) { // eslint-disable-line no-use-before-define\n\t\tcontext = context.elements[ 0 ];\n\t}\n\n\tif ( !( context instanceof HTMLElement ) && context !== document ) {\n\t\tcontext = document;\n\t}\n\n\treturn context;\n}\n\nfunction fetchElements( query, context, converter, selectorEngine ) {\n\tif ( !query ) {\n\t\tthrow new TypeError( 'Selector must be set.' );\n\t}\n\n\tif ( typeof query === 'string' ) {\n\t\tquery = converter.convert( query ).CSS;\n\t\treturn selectorEngine.find( query, context );\n\t} else if ( query instanceof HTMLElement ) {\n\t\treturn [\n\t\t\tquery\n\t\t];\n\t} else if ( query instanceof BEMQuery ) { // eslint-disable-line no-use-before-define\n\t\treturn query.elements;\n\t} else if ( typeof query === 'object' ) {\n\t\treturn Array.from( query );\n\t} else {\n\t\tthrow new TypeError( 'Selector must be a string, object, array or DOM element.' );\n\t}\n}\n\nfunction defineProperties( obj, elements ) {\n\tObject.defineProperty( obj, 'elements', {\n\t\tvalue: elements\n\t} );\n\n\tobj.elements.forEach( ( element, index ) => {\n\t\tObject.defineProperty( obj, index, {\n\t\t\tenumerable: true,\n\t\t\tget() {\n\t\t\t\treturn new BEMQuery( this.elements[ index ], document, this.converter, this.selectorEngine ); // eslint-disable-line no-use-before-define\n\t\t\t}\n\t\t} );\n\t}, obj );\n\n\tObject.defineProperty( obj, 'length', {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this.elements.length;\n\t\t}\n\t} );\n}\n\n/** Class representing elements collection. */\nclass BEMQuery {\n\t/**\n\t * Creates elements collection.\n\t *\n\t * @param {String|Iterable|HTMLElement} query Selector or\n\t * existing elements collection upon which the new elements collection\n\t * should be created.\n\t * @param {Document|HTMLElement|BEMQuery} context Context from which\n\t * elements should be fetched.\n\t * @param {Converter} converter BEM selector converter to be used.\n\t * @param {SelectorEngine} selectorEngine CSS selector engine to be used\n\t * by the current and descendant `BEMQuery` instances.\n\t * @class\n\t */\n\tconstructor( query, context, converter, selectorEngine ) {\n\t\tif ( !checkConverter( converter ) ) {\n\t\t\tthrow new TypeError( 'Converter must be an object with convert method defined.' );\n\t\t}\n\n\t\tif ( !checkSelectorEngine( selectorEngine ) ) {\n\t\t\tthrow new TypeError( 'SelectorEngine must be an object with find method defined.' );\n\t\t}\n\n\t\tthis.converter = converter;\n\t\tthis.selectorEngine = selectorEngine;\n\n\t\tcontext = determineContext( context );\n\n\t\tdefineProperties( this, fetchElements( query, context, converter, selectorEngine ) );\n\t}\n\n\t/**\n\t * Gets element with given index.\n\t *\n\t * @param {Number} index Element's index.\n\t * @return {BEMQuery} New BEMQuery instance with fetched element\n\t * as an only element in the collection.\n\t */\n\tget( index ) {\n\t\tindex = Number( index );\n\n\t\tif ( Number.isNaN( index ) ) {\n\t\t\tthrow new TypeError( 'Index must be a correct Number.' );\n\t\t} else if ( index < 0 ) {\n\t\t\tthrow new RangeError( 'Index must be greater or equal to 0.' );\n\t\t} else if ( index > ( this.elements.length - 1 ) ) {\n\t\t\tthrow new RangeError( 'Index cannot be greater than collection\\'s length.' );\n\t\t}\n\n\t\treturn new BEMQuery( this.elements[ index ], document, this.converter, this.selectorEngine );\n\t}\n\n\t/**\n\t * Executes callback on every element in the collection.\n\t *\n\t * @param {Function} callback Callback to be executed.\n\t * @return {BEMQuery} Current `BEMQuery` instance.\n\t */\n\teach( callback ) {\n\t\tif ( typeof callback !== 'function' ) {\n\t\t\tthrow new TypeError( 'Callback must be a function.' );\n\t\t}\n\n\t\tconst converter = this.converter;\n\t\tconst selectorEngine = this.selectorEngine;\n\n\t\tthis.elements.forEach( ( element ) => {\n\t\t\tcallback( new BEMQuery( element, document, converter, selectorEngine ) );\n\t\t} );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns iterator for contained elements.\n\t *\n\t * @return {Iterator} Returned iterator.\n\t */\n\t[ Symbol.iterator ]() {\n\t\tlet i = 0;\n\t\tconst elements = this.elements;\n\t\tconst converter = this.converter;\n\t\tconst selectorEngine = this.selectorEngine;\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tif ( i < elements.length ) {\n\t\t\t\t\tconst element = elements[ i++ ];\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: new BEMQuery( [ element ], document, converter, selectorEngine ),\n\t\t\t\t\t\tdone: false\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdone: true\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n}\n\n/**\n * BEMQuery instance factory.\n *\n * @param {String|Iterable|HTMLElement} query Selector or\n * existing elements collection upon which the new elements collection\n * should be created.\n * @param {Document|HTMLElement|BEMQuery} context Context from which\n * elements should be fetched.\n * @return {BEMQuery} New BEMQuery instance.\n */\nfunction factory( query, context = document ) {\n\tconst converter = bsc();\n\tconst selectorEngine = new SelectorEngine();\n\tconst bemQuery = new BEMQuery( query, context, converter, selectorEngine );\n\n\treturn bemQuery;\n}\n\nexport { BEMQuery };export default factory;\n//# sourceMappingURL=bemquery-core.js.map\n","/*! bemquery-async-dom v0.1.4 | (c) 2016 BEMQuery team | MIT license (see LICENSE) */\nimport { BEMQuery } from 'bemquery-core';\n\n/** Class storing queue of DOM operations. */\nclass Batch {\n\t/**\n\t * Constructing new batch.\n\t *\n\t * @class\n\t */\n\tconstructor() {\n\t\tthis.read = [];\n\t\tthis.write = [];\n\t}\n\n\t/**\n\t * Add new operation to the batch.\n\t *\n\t * @param {String} type Type of operation. Must be either \"read\" or \"write\".\n\t * @param {Function} fn Operation to be fired.\n\t * @return {BEMQuery} Current BEMQuery instance.\n\t */\n\tadd( type, fn ) {\n\n\t\tif ( type !== 'read' && type !== 'write' ) {\n\t\t\tthrow new TypeError( 'Type must be either \\'read\\' or \\'write\\'.' );\n\t\t}\n\n\t\tif ( typeof fn !== 'function' ) {\n\t\t\tthrow new TypeError( 'Task must be a function.' );\n\t\t}\n\n\t\tthis[ type ].push( fn );\n\t}\n\n\t/**\n\t * Run operations of given type.\n\t *\n\t * @param {String} type Type of operations to run. Must be either \"read\" or \"write\".\n\t * @return {Promise} Promise that will be fulfilled after running all tasks.\n\t */\n\trun( type = 'read' ) {\n\t\tif ( type !== 'read' && type !== 'write' ) {\n\t\t\tthrow new TypeError( 'Type must be either \\'read\\' or \\'write\\'.' );\n\t\t}\n\n\t\treturn new Promise( ( resolve ) => {\n\t\t\trequestAnimationFrame( () => {\n\t\t\t\tconst results = [];\n\n\t\t\t\tthis[ type ].forEach( ( fn ) => {\n\t\t\t\t\tresults.push( fn() );\n\t\t\t\t} );\n\n\t\t\t\tthis[ type ] = [];\n\n\t\t\t\treturn resolve( results );\n\t\t\t} );\n\t\t} );\n\t}\n}\n\n/**\n * Method that runs all read operations stored in batch\n *\n * @return {Promise} Promise returned by batch.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.read = function() {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\treturn this.batch.run( 'read' );\n};\n\n/**\n * Method that runs all write operations stored in batch\n *\n * @return {Promise} Promise returned by batch.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.write = function() {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\treturn this.batch.run( 'write' );\n};\n\n/**\n * Method for getting/setting inner HTML of all elements in collection\n *\n * @param {String} [newHTML] The new inner HTML value. If not specified,\n * the method will work as getter.\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.html = function( newHTML ) {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\tif ( typeof newHTML !== 'undefined' ) {\n\t\tnewHTML = String( newHTML );\n\n\t\tthis.batch.add( 'write', () => {\n\t\t\tconst elements = this.elements;\n\n\t\t\telements.forEach( ( element ) => {\n\t\t\t\telement.innerHTML = newHTML;\n\t\t\t} );\n\t\t} );\n\t} else {\n\t\tthis.batch.add( 'read', () => {\n\t\t\tconst elements = this.elements;\n\t\t\tconst htmls = [];\n\n\t\t\telements.forEach( ( element ) => {\n\t\t\t\thtmls.push( element.innerHTML );\n\t\t\t} );\n\n\t\t\treturn htmls;\n\t\t} );\n\t}\n\n\treturn this;\n};\n\nfunction processClasses( converter, element ) {\n\tconst states = [];\n\n\t[].forEach.call( element.classList, ( className ) => {\n\t\tconst state = converter.getStateFromClass( String( className ) );\n\n\t\tif ( state ) {\n\t\t\tstates.push( state );\n\t\t}\n\t} );\n\n\treturn states;\n}\n\n/**\n * Method for getting states from all elements in collection.\n *\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.getStates = function() {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\tconst elements = this.elements;\n\n\tthis.batch.add( 'read', () => {\n\t\tconst result = [];\n\n\t\telements.forEach( ( element ) => {\n\t\t\tresult.push( processClasses( this.converter, element ) );\n\t\t} );\n\n\t\treturn result;\n\t} );\n\n\treturn this;\n};\n//# sourceMappingURL=bemquery-async-dom.js.map\n","/*! bemquery-selector-engine v0.2.4 | (c) 2016 BEMQuery team | MIT license (see LICENSE) */\n/** Simple selector engine. */\nclass SelectorEngine {\n\t/**\n\t * Find elements using passed selector.\n\t *\n\t * @param {String} selector CSS selector.\n\t * @param {HTMLElement|Document} context Context\n\t * in which element should be found.\n\t * @returns {HTMLElement[]} Found elements.\n\t */\n\tfind( selector, context = document ) {\n\t\tlet tmpId = false;\n\n\t\tif ( context !== document ) {\n\t\t\tif ( !context.id ) {\n\t\t\t\ttmpId = true;\n\t\t\t\tcontext.id = `BEMQueryTMP_${Date.now()}`;\n\t\t\t}\n\n\t\t\tselector = `#${context.id} ${selector}`;\n\t\t}\n\n\t\tconst elements = Array.from( context.querySelectorAll( selector ) );\n\n\t\tif ( tmpId ) {\n\t\t\tcontext.removeAttribute( 'id' );\n\t\t}\n\n\t\treturn elements;\n\t}\n}\n\nexport default SelectorEngine;\n//# sourceMappingURL=bemquery-selector-engine.js.map\n","/*! bemquery-dom-events v0.1.4 | (c) 2016 BEMQuery team | MIT license (see LICENSE) */\nimport { BEMQuery } from 'bemquery-core';\n\n/** Storage for events listeners */\nclass ListenersStorage {\n\t/**\n\t * Creates new storage for event lsiteners\n\t *\n\t * @class\n\t */\n\tconstructor() {\n\t\tthis.storage = new WeakMap();\n\t}\n\n\t/**\n\t * Adds event listener to the storage.\n\t *\n\t * @param {Object} element Element to which listener is binded.\n\t * @param {String} type Type of event.\n\t * @param {String} selector Selector for event delegation.\n\t * @param {Function} fn Original callback.\n\t * @param {Function} listener Created listener.\n\t * @return {void}\n\t */\n\tadd( element, type, selector, fn, listener ) {\n\t\tlet listeners = {};\n\n\t\tif ( this.storage.has( element ) ) {\n\t\t\tlisteners = this.storage.get( element );\n\t\t}\n\n\t\tif ( typeof listeners[ type ] === 'undefined' ) {\n\t\t\tlisteners[ type ] = {};\n\t\t}\n\n\t\tif ( typeof listeners[ type ][ selector ] === 'undefined' ) {\n\t\t\tlisteners[ type ][ selector ] = [];\n\t\t}\n\n\t\tlisteners[ type ][ selector ].push( [ fn, listener ] );\n\n\t\tthis.storage.set( element, listeners );\n\t}\n\n\t/**\n\t * Gets event listener that matches the given criteria.\n\t *\n\t * @param {Object} element Element to which listener is binded.\n\t * @param {String} type Type of event.\n\t * @param {String} selector Selector for event delegation.\n\t * @param {Function} fn Original callback.\n\t * @return {Function} Event listener.\n\t */\n\tget( element, type, selector, fn ) {\n\t\tif ( !this.storage.has( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst listeners = this.storage.get( element );\n\n\t\tif ( typeof listeners[ type ] === 'undefined' || typeof listeners[ type ][ selector ] === 'undefined' ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor ( let pair of listeners[ type ][ selector ] ) { // eslint-disable-line prefer-const\n\t\t\tif ( pair[ 0 ] === fn ) {\n\t\t\t\treturn pair[ 1 ];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes event listener that matches the given criteria.\n\t *\n\t * @param {Object} element Element to which listener is binded.\n\t * @param {String} type Type of event.\n\t * @param {String} selector Selector for event delegation.\n\t * @param {Function} fn Original callback.\n\t * @return {Function} Event listener.\n\t */\n\tremove( element, type, selector, fn ) {\n\t\tif ( !this.storage.has( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst listeners = this.storage.get( element );\n\n\t\tif ( typeof listeners[ type ] === 'undefined' || typeof listeners[ type ][ selector ] === 'undefined' ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlisteners[ type ][ selector ].forEach( ( pair, i ) => {\n\t\t\tif ( pair[ 0 ] === fn ) {\n\t\t\t\tlisteners[ type ][ selector ].splice( i, 1 );\n\t\t\t}\n\t\t} );\n\n\t\treturn null;\n\t}\n}\n\nconst storage = new ListenersStorage();\n\n/**\n * Method for adding event listener to the element.\n *\n * @param {String} type Type of the event.\n * @param {String|Function} selector If that parameter is a string,\n * then it's used to construct checking for the event delegation.\n * However if function is passed, then it becomes the event's listener.\n * @param {Function} callback If the second parameter is a string, this\n * function will be used as an event's listener.\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.on = function( type, selector, callback ) {\n\tlet listener;\n\n\tif ( typeof type !== 'string' || !type ) {\n\t\tthrow new TypeError( 'Type of event must be a non-empty string.' );\n\t}\n\n\tif ( ( typeof selector !== 'string' && typeof selector !== 'function' ) || !selector ) {\n\t\tthrow new TypeError( 'Selector must be a non-empty string or function.' );\n\t}\n\n\tif ( typeof selector === 'string' ) {\n\t\tif ( typeof callback !== 'function' ) {\n\t\t\tthrow new TypeError( 'Callback must be a function.' );\n\t\t}\n\n\t\tselector = this.converter.convert( selector ).CSS;\n\t\tselector = `${selector}, ${selector} *`;\n\n\t\tlistener = ( evt ) => {\n\t\t\tif ( evt.target.matches( selector ) ) {\n\t\t\t\tcallback( evt );\n\t\t\t}\n\t\t};\n\t} else {\n\t\tlistener = selector;\n\t}\n\n\tthis.elements.forEach( ( element ) => {\n\t\telement.addEventListener( type, listener, false );\n\n\t\tif ( typeof selector === 'string' ) {\n\t\t\tstorage.add( element, type, selector, callback, listener );\n\t\t}\n\t} );\n\n\treturn this;\n};\n\n/**\n * Method for removing event listener from the element.\n *\n * @param {String} type Type of the event.\n * @param {String|Function} selector If that parameter is a string,\n * then it's used to construct checking for the event delegation.\n * However if function is passed, then it becomes the event's listener.\n * @param {Function} callback If the second parameter is a string, this\n * function will be used as an event's listener.\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.off = function( type, selector, callback ) {\n\tlet listener;\n\n\tif ( typeof type !== 'string' || !type ) {\n\t\tthrow new TypeError( 'Type of event must be a non-empty string.' );\n\t}\n\n\tif ( ( typeof selector !== 'string' && typeof selector !== 'function' ) || !selector ) {\n\t\tthrow new TypeError( 'Selector must be a non-empty string or function.' );\n\t}\n\n\tif ( typeof selector === 'string' ) {\n\t\tif ( typeof callback !== 'function' ) {\n\t\t\tthrow new TypeError( 'Callback must be a function.' );\n\t\t}\n\n\t\tselector = this.converter.convert( selector ).CSS;\n\t\tselector = `${selector}, ${selector} *`;\n\t} else {\n\t\tlistener = selector;\n\t}\n\n\tthis.elements.forEach( ( element ) => {\n\t\tif ( typeof selector === 'string' ) {\n\t\t\tlistener = storage.get( element, type, selector, callback );\n\n\t\t\tstorage.remove( element, type, selector, callback );\n\t\t}\n\t\telement.removeEventListener( type, listener, false );\n\t} );\n\n\treturn this;\n};\n//# sourceMappingURL=bemquery-dom-events.js.map\n"],"names":["endsWithModifier","selector","bemConfig","regex","RegExp","elemSeparator","modifierSeparator","match","getSelectorWithoutModifier","substring","lastIndexOf","convertToken","tokens","config","rules","delimeter","shift","rule","token","default","SyntaxError","convert","Object","keys","filter","splitRule","join","splittedSelector","split","factory","converterConfig","defaultConfig","converter","Converter","checkConverter","checkSelectorEngine","selectorEngine","find","determineContext","context","BEMQuery","elements","HTMLElement","document","fetchElements","query","TypeError","CSS","Array","from","defineProperties","obj","defineProperty","forEach","element","index","this","length","bsc","SelectorEngine","bemQuery","processClasses","states","call","classList","className","state","getStateFromClass","String","push","Selector","BEM","freeze","bem","convertedSelector","tmpId","id","Date","now","querySelectorAll","removeAttribute","Number","isNaN","RangeError","callback","Symbol","iterator","i","Batch","read","write","type","fn","Promise","resolve","results","prototype","batch","run","html","newHTML","add","_this2","innerHTML","htmls","getStates","result","_this3","ListenersStorage","storage","WeakMap","listener","listeners","has","get","set","pair","splice","on","evt","target","matches","addEventListener","off","remove","removeEventListener"],"mappings":"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"}