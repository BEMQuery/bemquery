/*! bemquery v0.1.5 | (c) 2016-2017 BEMQuery team | MIT license (see LICENSE) */(function(h,i){'object'==typeof exports&&'undefined'!=typeof module?module.exports=i():'function'==typeof define&&define.amd?define(i):h.bemquery=i()})(this,function(){'use strict';function h(C,D){const E=new RegExp(`[^${D.elemSeparator}${D.modifierSeparator}]+${D.modifierSeparator}[^${D.elemSeparator}${D.modifierSeparator}]+$`,'g');return!!C.match(E)}function i(C,D){return` ${C.substring(C.lastIndexOf('.'),C.lastIndexOf(D))}`}function j(C,D,E=''){const F=D.rules,G=C.shift();let H,I;if(!G)return E;if(E?(I=C.shift(),H=F[G]):(I=G,H=F.default),'function'!=typeof H)throw new SyntaxError('Malformed BEM rule');return E+=H(I,D,E),j(C,D,E)}function k(C,D){const E=Object.keys(D.rules).filter(H=>{return'default'!==H}),F=new RegExp(`(${E.join('|')})`,'g'),G=C.split(F);return C=j(G,D),C}function l(C=u){const D=new v(C);return D}function m(C){return'object'==typeof C&&'function'==typeof C.convert}function n(C){return'object'==typeof C&&'function'==typeof C.find}function o(C){return C instanceof x&&(C=C.elements[0]),C instanceof HTMLElement||C===document||(C=document),C}function p(C,D,E,F){if(!C)throw new TypeError('Selector must be set.');if('string'==typeof C)return C=E.convert(C).CSS,F.find(C,D);if(C instanceof HTMLElement)return[C];if(C instanceof x)return C.elements;if('object'==typeof C)return Array.from(C);throw new TypeError('Selector must be a string, object, array or DOM element.')}function q(C,D){Object.defineProperty(C,'elements',{value:D}),C.elements.forEach((E,F)=>{Object.defineProperty(C,F,{enumerable:!0,get(){return new x(this.elements[F],document,this.converter,this.selectorEngine)}})},C),Object.defineProperty(C,'length',{enumerable:!0,get(){return this.elements.length}})}function s(C,D){const E=[];return[].forEach.call(D.classList,F=>{const G=C.getStateFromClass(F+'');G&&E.push(G)}),E}class t{constructor(C,D){this.BEM=C,this.CSS=D,Object.freeze(this)}}const u={bem:{elemSeparator:'__',modifierSeparator:'_'},rules:{default(C){return`.${C}`},' > '(C,D){return` ${D.rules.default(C)}`},' '(C,D,E){return h(E,D.bem)?`${i(E,D.bem.modifierSeparator)}${D.bem.elemSeparator}${C}`:`${D.bem.elemSeparator}${C}`},':'(C,D){return`${D.bem.modifierSeparator}${C}`}}};class v{constructor(C=u){this.config=C}convert(C){const D=k(C,this.config);return new t(C,D)}getStateFromClass(C){if('string'!=typeof C)throw new TypeError('Class must be a string.');const D=this.config.bem,E=new RegExp(`[^${D.elemSeparator}${D.modifierSeparator}]+${D.modifierSeparator}([^${D.elemSeparator}${D.modifierSeparator}]+)$`),F=C.match(E);return F?F[1]:null}}class w{find(C,D=document){let E=!1;D!==document&&(!D.id&&(E=!0,D.id=`BEMQueryTMP_${Date.now()}`),C=`#${D.id} ${C}`);const F=Array.from(D.querySelectorAll(C));return E&&D.removeAttribute('id'),F}}class x{constructor(C,D,E,F){if(!m(E))throw new TypeError('Converter must be an object with convert method defined.');if(!n(F))throw new TypeError('SelectorEngine must be an object with find method defined.');this.converter=E,this.selectorEngine=F,D=o(D),q(this,p(C,D,E,F))}get(C){if(C=+C,Number.isNaN(C))throw new TypeError('Index must be a correct Number.');else if(0>C)throw new RangeError('Index must be greater or equal to 0.');else if(C>this.elements.length-1)throw new RangeError('Index cannot be greater than collection\'s length.');return new x(this.elements[C],document,this.converter,this.selectorEngine)}each(C){if('function'!=typeof C)throw new TypeError('Callback must be a function.');const D=this.converter,E=this.selectorEngine;return this.elements.forEach(F=>{C(new x(F,document,D,E))}),this}[Symbol.iterator](){let C=0;const D=this.elements,E=this.converter,F=this.selectorEngine;return{next(){if(C<D.length){const G=D[C++];return{value:new x([G],document,E,F),done:!1}}return{done:!0}}}}}var y=Object.freeze({BEMQuery:x,default:function(C,D=document){const E=l(),F=new w,G=new x(C,D,E,F);return G}});class z{constructor(){this.read=[],this.write=[]}add(C,D){if('read'!==C&&'write'!==C)throw new TypeError('Type must be either \'read\' or \'write\'.');if('function'!=typeof D)throw new TypeError('Task must be a function.');this[C].push(D)}run(C='read'){if('read'!==C&&'write'!==C)throw new TypeError('Type must be either \'read\' or \'write\'.');return new Promise(D=>{requestAnimationFrame(()=>{const E=[];return this[C].forEach(F=>{E.push(F())}),this[C]=[],D(E)})})}}x.prototype.read=function(){return this.batch||(this.batch=new z),this.batch.run('read')},x.prototype.write=function(){return this.batch||(this.batch=new z),this.batch.run('write')},x.prototype.html=function(C){return this.batch||(this.batch=new z),'undefined'==typeof C?this.batch.add('read',()=>{const D=this.elements,E=[];return D.forEach(F=>{E.push(F.innerHTML)}),E}):(C+='',this.batch.add('write',()=>{const D=this.elements;D.forEach(E=>{E.innerHTML=C})})),this},x.prototype.getStates=function(){this.batch||(this.batch=new z);const C=this.elements;return this.batch.add('read',()=>{const D=[];return C.forEach(E=>{D.push(s(this.converter,E))}),D}),this};const B=new class{constructor(){this.storage=new WeakMap}add(C,D,E,F,G){let H={};this.storage.has(C)&&(H=this.storage.get(C)),'undefined'==typeof H[D]&&(H[D]={}),'undefined'==typeof H[D][E]&&(H[D][E]=[]),H[D][E].push([F,G]),this.storage.set(C,H)}get(C,D,E,F){if(!this.storage.has(C))return null;const G=this.storage.get(C);if('undefined'==typeof G[D]||'undefined'==typeof G[D][E])return null;for(let H of G[D][E])if(H[0]===F)return H[1];return null}remove(C,D,E,F){if(!this.storage.has(C))return null;const G=this.storage.get(C);return'undefined'==typeof G[D]||'undefined'==typeof G[D][E]?null:(G[D][E].forEach((H,I)=>{H[0]===F&&G[D][E].splice(I,1)}),null)}};return x.prototype.on=function(C,D,E){let F;if('string'!=typeof C||!C)throw new TypeError('Type of event must be a non-empty string.');if('string'!=typeof D&&'function'!=typeof D||!D)throw new TypeError('Selector must be a non-empty string or function.');if('string'==typeof D){if('function'!=typeof E)throw new TypeError('Callback must be a function.');D=this.converter.convert(D).CSS,D=`${D}, ${D} *`,F=G=>{G.target.matches(D)&&E(G)}}else F=D;return this.elements.forEach(G=>{G.addEventListener(C,F,!1),'string'==typeof D&&B.add(G,C,D,E,F)}),this},x.prototype.off=function(C,D,E){let F;if('string'!=typeof C||!C)throw new TypeError('Type of event must be a non-empty string.');if('string'!=typeof D&&'function'!=typeof D||!D)throw new TypeError('Selector must be a non-empty string or function.');if('string'==typeof D){if('function'!=typeof E)throw new TypeError('Callback must be a function.');D=this.converter.convert(D).CSS,D=`${D}, ${D} *`}else F=D;return this.elements.forEach(G=>{'string'==typeof D&&(F=B.get(G,C,D,E),B.remove(G,C,D,E)),G.removeEventListener(C,F,!1)}),this},y});
//# sourceMappingURL=bemquery.umd.js.map
